<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>算法题中比较难的-动态规范问题</title>
</head>
<body>
<ul>
  <li>关键是找到状态转移方程</li>
  <li>dp(n) = dp(n-1) + dp(n-2) -- 斐波那契数列</li>
  <li>🐸跳台阶 n个台阶有多少种跳法</li>
</ul>
<script>
  // 实现 斐波那契数列 - 递归函数
  function fibonacci(n) {
    let fibSeries = [0, 1];
    for (let i = 2; i < n; i++) {
      fibSeries[i] = fibSeries[i - 1] + fibSeries[i - 2];
    }
    return fibSeries;
  }

  // console.log(fibonacci(10));

  // 递归方式实现
  function fibonacciRecursive(n) {
    if (n <= 0) {
      return [];
    } else if (n === 1) {
      return [0];
    } else if (n === 2) {
      return [0, 1];
    } else {
      let series = fibonacciRecursive(n - 1);
      series.push(series[series.length - 1] + series[series.length - 2]);
      return series;
    }
  }

  // console.log(fibonacciRecursive(12));

  // 青蛙跳台阶问题 n 阶
  /**
   * 青蛙跳台阶问题
   * @param n
   * @returns {*|number}
   */
  function jumpFloor(n) {
    if (n <= 0) {
      return 0;
    } else if (n === 1) {
      return 1;
    } else if (n === 2) {
      return 2;
    } else {
      return jumpFloor(n - 1) + jumpFloor(n - 2);
    }
  }

  // console.log(jumpFloor(10))
  // 寻找最大的葫芦 扑克游戏
  /**
   * 问题描述
   * 在一场经典的德州扑克游戏中，有一种牌型叫做“葫芦”。“葫芦”由五张牌组成，其中包括三张相同牌面值的牌
   * a 和另外两张相同牌面值的牌。如果两个人同时拥有“葫芦”，我们会优先比较牌 a 的大小，若牌a 相同则再比较牌
   * b 的大小。在这个问题中，我们对“葫芦”增加了一个限制：组成“葫芦”的五张牌牌面值之和不能超过给定的最大值
   * max。牌面值的大小规则为：A > K > Q > J > 10 > 9 > ... > 2，其中 A 的牌面值为1，K 为13，依此类推。
   *
   * 给定一组牌，你需要找到符合规则的最大的“葫芦”组合，并输出其中三张相同的牌面和两张相同的牌面。
   * 如果找不到符合条件的“葫芦”，则输出 “0, 0”。
   *
   * 测试样例
   * 输入：n = 9, max = 34, array = [6, 6, 6, 8, 8, 8, 5, 5, 1]
   * 输出：[8, 5]
   *
   * 输入：n = 9, max = 37, array = [9, 9, 9, 9, 6, 6, 6, 6, 13]
   * 输出：[6, 9]
   *
   * 输入：n = 9, max = 40, array = [1, 11, 13, 12, 7, 8, 11, 5, 6]
   * 输出：[0, 0]
   */

  function  findHulu(n, max, array) {
    if (n < 5 || array.length < 5) {
      return [0, 0];
    }
    //  统计每个排面值出现的次数
    let countMap = new Map();
    // 简洁的一种写法
    for (let card of array) {
      // countMap[card] = (countMap[card] || 0) + 1;
      countMap.set(card, (countMap.get(card) || 0) + 1);
    }
    // 面值排序 需要考虑 A 的特殊情况 1 代表 A 应该排在最前面， 但 计算值时 需要 转换为 1
    // console.log(countMap.keys());
    let sortedKeys = Array.from(countMap.keys()).map(key => key === 1 ? 14 : key).sort((a, b) => b - a);
    console.log(`countMap:`,countMap, 'sortedKeys',sortedKeys)
    for (let i = 0; i < sortedKeys.length; i++) {
      let key = sortedKeys[i];
      let originalKey = key === 14 ? 1 : key; // 还原 A的 特殊情况 用于 mas 计算比较
      let count = countMap.get(originalKey);
      // 找到最大的三张牌
      if (count >= 3) {
        // 找到最大的两张牌
        for (let j = 0; j < sortedKeys.length; j++) {
          if(i !== j) { // 防止相同的牌
            let key2 = sortedKeys[j];
            let originalKey2 = key2 === 14 ? 1 : key2;
            let count2 = countMap.get(originalKey2);
            if (count2 >=2 && originalKey * 3 + originalKey2 * 2 <= max) {
              return [originalKey, originalKey2];
            }
          }
        }
      }
    }
    // 不符合时 返回
    return [0, 0];
  }

  console.log(findHulu(9, 34, [6, 6, 6, 8, 8, 8, 5, 5, 1])); // [8, 5]
  console.log(findHulu(9, 37, [9, 9, 9, 9, 6, 6, 6, 6, 13])); // [6, 9]
  console.log(findHulu(9, 40, [1, 11, 13, 12, 7, 8, 11, 5, 6])); // [0, 0]
  console.log(findHulu(9, 79, [1, 5, 1, 12, 7, 1, 11, 5, 6])); // [1, 5]

  //  小E 的怪物挑战 游戏
  /**
   * 小E在一个游戏中遇到了 n 个怪物，每个怪物都有其特定的血量值hi和攻击力ai。
   * 小E的初始血量是 H， 攻击力为 A。他可以击败哪些 血量和攻击力 都小于 他自身的怪物
   * 每击败一个怪物后，小E的血量和攻击力都会变为该怪物的血量值和攻击力。
   * 小E想知道 他最多能击败多少个怪物
   *
   *
   *测试样例
   * 输入：n = 3, H = 4, A = 5, h = [1,2,3], a = [3,2,1]
   * 输出： 1
   *
   *
   */
</script>
</body>
</html>
