<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>数据结构和算法</title>
  <script>
    // 直插排序
    let arr = [7, 6, 9, 3, 1, 5, 2, 4]
    let n = 0;
    let arr2 = [...arr]
    let arr3 = [...arr]
    for(let i = 1; i < arr.length; i++){
      // console.log(i);
      for(let j = i; j > 0; j-- ){ // 二次循环 第二个元素 向前逐一对比
        n++; // 内部循环次数
        if(arr[j] - arr[j-1] < 0){
          // 交换数据
          // console.log(n)
          let t = arr[j];
          arr[j] = arr[j-1];
          arr[j-1] = t;
        } else {
          break
        }
      }
    }

    console.log(`直插排序：循环次数 ${n} , ${arr.join(',')}`);
    // sort 方法不同浏览器底层实现算法不一样  火狐使用的是 直插排序 与上面算法循环次数一致
    // chorme 不一样 数组长度不同 会 直插排序与快速排序结合使用···
    arr2.sort((a, b) => {
      console.log('time');// 循环次数
      return a - b;
    } )
    console.log(`arry 默认 sort 方法： ${arr2.join(',')}`)

    // 直插排序 优化 - 希尔排序 () 
    /** 
     *  sell sort
     *  缩小增量的方式进行比对
     *  初始间隔  gap = length/2 gap = gap/2
     *  
    **/
    function shellSort(arr) {
      debugger
      let n = 0;
      for(let gap = Math.floor(arr.length/2); gap > 0; gap = Math.floor(gap/2) ){
        // 内循环 基本与 插值排序写法基本一致 只是每次移动步长为gap
        for(let i = gap; i < arr.length; i++) {
          let j = i;
          let temp = arr[j];
          for(; j > 0; j-=gap ){ //只进行每个分组的首尾对比
            n++
            if(temp >= arr[j-gap]) { // 无需置换
              break
            }
            arr[j] = arr[j-gap]
            arr[j-gap] = temp;
          }
          // arr[j] = temp
        }
      }
     
      console.log(`shellSort: 排序循环次数：${n},${arr}`)
    }

    shellSort(arr3);
    console.log(`sellsort 方法： ${arr3.join(',')}`)

  </script>
</head>
<body>
  
</body>
</html>